export const metadata = {
  "date": "2022-02-18T19:26:54.937Z",
  "title": "Let the Browser Do It for You",
  "description": "A dummy description",
  "image": require("./browser.png"),
  "imageAlt": "A little browser lifting weights"
}

Browsers are an incredible feat of engineering. Just to give you an idea, the Chromium codebase contains about [35 million lines of source code](https://en.wikipedia.org/wiki/Chromium_(web_browser)#:~:text=35%20million%20source%20lines%20of%20code.). It's honestly so mind boggling to me that they work at all.

While browsers can do a lot of stuff, there are things we developers have to implement ourselves because they are not supported natively.

In those cases we either:

- handcraft the missing functionality
- install yet another package while wishing we didn't have to add another 50kb to our JavaScript bundle.

Using built-in browser features is not a novel idea. Choosing `border-radius` over sprites may sound obvious nowadays but we have to keep in mind that things move quickly. There are a lot of things we take for granted that were just hopes and dreams not long ago. Something that can't be done today might be possible next year so it's important to try to stay up to date with what's getting shipped.

I've realised that once I have found a way of doing things, I tend to stick with it and accept it as the status quo. I'll be out there reusing techniques from my old bag of tricks without revisiting them to see if anything changed in the browser landscape.

This post is mostly a reminder to myself that I don't always need to re-invent the wheel and that I can, in most cases, and sometimes with a bit of patience, rely on the browser to do the heavy lifting for me.

You have a choice as a developer, you can choose to go the hard way, or you can **let the browser do it for you**.

## Before we start

I need to mention that it's not always possible to rely on some of the techniques below if you are building an isomorphic application since some of them rely on browser APIs that aren't available in the Node.js runtime. But hey, things move fast, I'm looking at you [#41749](https://github.com/nodejs/node/pull/41749).

## But why would you want to do that?

The most obvious reasons for me is. Not only we don't have to spend time re-writing code that smarter people already wrote before us, we can also enjoy these benefits:

- **It's fast** - Browser API are almost always going to be faster than their JavaScript counterpart.
- **Size** - By relying on code that's shipped with the browser, we don't need to add yet another library which would increase the size of your JavaScript bundle.
- **Robustness** - This code has been battle tested
- **Maintainability** - The most maintainable code is no code at all.

This is a **non-exhaustive** list.

## Dates

If there's one thing a developer shouldn't have to deal with, it's dates, more specifically: timezones.

## Lazy Loading Images

This one's pretty new so it's not fully supported by every browser yet. As of this writing, Safari is still lagging behind. Even though not every browser supports it, it can still be a good progressive enhancement.
data-src, the disadvantage of such approach is that…

```html
<img src="..." width="100" height="100" alt="..." loading="lazy" />
```

## Removing Accents/Diacritics in a String

Gone are the days where we had to use lodash's [`deburr`](https://lodash.com/docs/4.17.15#deburr) function to remove accents from a string.

```javascript
const removeAccents = (str) => {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
};

const output = removeAccents("Hétérogénéité");
```

## Manipulating query strings

I've lost count of the number of times I've seen API calls like this:

```javascript
fetch(
  `https://example.com?param1=${encodeURIComponent(
    someValue
  )}&param2=${encodeURIComponent(someOtherValue)}&param3=${encodeURIComponent(
    yetAnotherValue
  )}`
);
```

(I'm guilty of that one too)

While this technically works, there are many things wrong with this approach.

- It is hard to read, even more so with prettier doing its best to keep the line length under control.
- It's fragile, we're one bad keystroke away from messing up our URL.
- `encodeURIComponent` doesn't properly encode some characters (+ vs %20 for spaces)

There is this thing called [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and it happens to be really well supported.

```javascript
const params = new URLSearchParams({
  param1: someValue,
  param2: someOtherValue,
  param3: yetAnotherValue,
});

fetch(`https://example.com?${params}`);
```

This is even fully supported by Node.js since version 10 ✨

## Parsing URLs

Similar to the query string thing above, I've encountered this one plenty of times (disclaimer, I'm guilty of doing this too):

```javascript
const url = new URL(
  "https://username:password@example.com:3000/path?query=1#hash"
);

console.log(url);
```

Output:

```
{
  hash: "#hash",
  host: "example.com:3000",
  hostname: "example.com",
  href: "https://username:password@example.com:3000/path?query=1#hash",
  origin: "https://example.com:3000",
  password: "password",
  pathname: "/path",
  port: "3000",
  protocol: "https:",
  search: "?query=1",
  searchParams: URLSearchParams {},
  username: "username"
}
```

## HTML String Encoding

- using a [textNode](http://developer.mozilla.org/en-US/docs/Web/API/Document/createTextNode)
- using a [link to another page](/) with a piece of `inline code`
- using a [link to an external webite](https://example.com)

We sometimes need to sanitize untrusted strings, these are usually strings of text that are provided by users. This technique helps prevent XSS attacks by encoding strings before rendering them into our document.

If you look on the internet for how to html-encode a piece of text, you will mostly find answers that involves regexes:

- [How to encode a string in JavaScript for displaying in HTML?](https://stackoverflow.com/questions/14129953/how-to-encode-a-string-in-javascript-for-displaying-in-html)
- [How to escape HTML](https://stackoverflow.com/questions/3043775/how-to-escape-html)

Personally, the more I can stay away from regexes, the better. I'm not saying rexeges should be avoided at all cost but it's just that they get thrown around a lot and often they are not the right tool for the job.

If there's one thing browsers are good at, it's handling HTML.

```javascript
const htmlEncode = (str) => {
  const textarea = document.createElement("textarea");
  const textNode = document.createTextNode(str);

  textarea.appendChild(textNode);

  return textarea.innerHTML;
};

const htmlEncodedString = htmlEncode(
  `Hello world <img src="" onerror="alert('xss')" />`
);
```

Output:

```
Hello world &lt;img src="" onerror="alert('xss')" /&gt;
```

## Convert to absolute URL

```javascript
const convertToAbsoluteUrl = (base, relativeUrl) => {
  return new URL(relativeUrl, base).toString();
};
```

## Query String Parsing

```javascript
const parseQueryString = (query) => {
  return Object.fromEntries(new URLSearchParams(query).entries());
};

const queryParams = parseQueryString(`?query=1&test=2`);
```

## Email Address Validation

This technique leverages the build-in browser validation.

Constraint Validation API: https://developer.mozilla.org/en-US/docs/Web/API/Constraint_validation

```javascript
const validateEmail = (() => {
  const input = document.createElement("input");

  input.type = "email";
  input.required = true;

  return (email) => {
    input.value = email;

    return input.checkValidity();
  };
})();

const isValid = validateEmail(`test@example.com`);
```

This technique won't work server-side as it relies on the DOM API.

## Extract text from HTML

```javascript
const stripHtml = (html) => {
  const { documentElement } = new DOMParser().parseFromString(
    html,
    "text/html"
  );

  return documentElement.textContent;
};

const text = stripHtml(`Hello world <img src="" onerror="alert('xss')" />`);
```

Output:

```
Hello world
```

## Other techniques

- scroll snapping
- encryption
- smooth scrolling