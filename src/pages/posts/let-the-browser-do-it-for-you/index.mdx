export const metadata = {
  date: "2022-02-18T19:26:54.937Z",
  title: "Let the Browser Do It for You",
  description: "A dummy description",
  image: require("./browser.png"),
  imageAlt: "A little browser lifting weights",
};

Browsers are an incredible feat of engineering. According to wikipedia, the Chromium codebase contains about [35 million lines of source code](<https://en.wikipedia.org/wiki/Chromium_(web_browser)#:~:text=35%20million%20source%20lines%20of%20code.>). It's honestly so mind boggling to me that they work at all.

While browsers can do a ton of stuff, there are features we developers have to implement ourselves because they are not supported natively.

In those cases we either:

- handcraft the missing functionality ourselves
- install yet another package while wishing we didn't have to add another 50kb to our JavaScript bundle

Using built-in browser features is not a novel idea. Choosing `border-radius` over background sprites may sound obvious nowadays but we have to keep in mind that things move quickly. There are a lot of things we take for granted that were just hopes and dreams not long ago. Something that can't be done today might be possible next year so it's important to try to stay up to date with what's getting shipped.

I've realised that once I have found a way of doing things, I tend to stick with it and accept it as the status quo. I'll be out there reusing techniques from my old bag of tricks without revisiting them to see if anything changed in the browser landscape.

This post is mostly a reminder to myself that I don't always need to re-invent the wheel and that I can, in most cases, and sometimes with a bit of patience, rely on the browser to do the heavy lifting for me.

You have a choice as a developer, you can choose to go the hard way, or you can **let the browser do it for you**.

## Before we start

I need to mention that it's not always possible to rely on some of the techniques below if you are building an isomorphic application since some of them rely on browser APIs that aren't available in the Node.js runtime. But hey, things move fast, I'm looking at you [#41749](https://github.com/nodejs/node/pull/41749).

### But why would you want to do that?

The most obvious reasons for me is. Not only we don't have to spend time re-writing code that smarter people already wrote before us, we can also enjoy these benefits:

- **It's fast** - Browser API are almost always going to be faster than their JavaScript counterpart.
- **Size** - By relying on code that's shipped with the browser, we don't need to add yet another library which would increase the size of your JavaScript bundle.
- **Robustness** - The code has been battle-tested.
- **Maintainability** - The most maintainable code is no code at all.

## URLs

Dealing with URLs is super common when developing websites. It's also super hard to get right if trying to do it by hand. There are so many edge cases, better let the browser handle them.

### Query String Parsing

```javascript
const parseQueryString = (queryString) => {
  return Object.fromEntries(new URLSearchParams(queryString).entries());
};

const queryParams = parseQueryString(`?query=1&test=Hello%20World`);

console.log(queryParams);
```

### Manipulating query strings

I've lost count of the number of times I've seen API calls like this:

```javascript
const someString = "someString";
const someBoolean = true;
const someNumber = 42;

await fetch(
  `https://example.com?a=${encodeURIComponent(
    someString
  )}&b=${someBoolean}&c=${someNumber}`
);
```

While this works, there are many things wrong with this approach:

- It is hard to read, even more so with prettier doing its best to keep the line length under control.
- It's fragile, we're one bad keystroke away from messing up our URL.
- We have to remember to call `encodeURIComponent` to properly encode string parameters

In the past I've used the [qs](https://www.npmjs.com/package/qs) package to address all the above but there is better alternative.

There is this thing called [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and it happens to be really well supported.

```javascript
const someString = "someString";
const someBoolean = true;
const someNumber = 42;

const queryString = new URLSearchParams({
  a: someString,
  b: someBoolean,
  c: someNumber,
});

await fetch(`https://example.com?${queryString}`);
```

Compared to the first example above, I think this looks much cleaner.

This is even fully supported by Node.js since version 10 ✨

### Manipulating URLs

I gave birth to this monstrosity more than once:

```javascript
const queryString = "http://localhost?test=1".split("?")[1];

console.log(queryString);
```

It's a quick and dirty way of extracting a query string from a URL but it's brittle. Depending on the data you're dealing with, you might have urls that also includes a fragment (`#anchor`).

```javascript
console.log("http://localhost?test=1#hash".split("?")[1]);
```

### Parsing URLs

Similar to the query string thing above, I've encountered this one plenty of times (disclaimer, I'm guilty of doing this too):

```javascript
console.log(
  new URL("https://username:password@example.com:3000/path?query=1#hash")
);
```

### Absolute URLs

The `URL` constructor can also be used for converting relative URLs into absolute ones, similar to `url.resolve` in Node.js.

```javascript
const convertToAbsoluteUrl = (base, relativeUrl) => {
  return new URL(relativeUrl, base).toString();
};

const absoluteUrl = convertToAbsoluteUrl(
  "https://base-url/path/",
  "../relative-path"
);

console.log(absoluteUrl);
console.log(absoluteUrl);
console.log(absoluteUrl);
```

## Strings

### HTML String Encoding

- using a [textNode](http://developer.mozilla.org/en-US/docs/Web/API/Document/createTextNode)
- using a [link to another page](/) with a piece of `inline code`
- using a [link to an external webite](https://example.com)

We sometimes need to sanitize untrusted strings, these are usually strings of text that are provided by users. This technique helps prevent XSS attacks by encoding strings before rendering them into our document.

If you look on the internet for how to html-encode a piece of text, you will mostly find answers that involves regexes:

- [How to encode a string in JavaScript for displaying in HTML?](https://stackoverflow.com/questions/14129953/how-to-encode-a-string-in-javascript-for-displaying-in-html)
- [How to escape HTML](https://stackoverflow.com/questions/3043775/how-to-escape-html)

Personally, the more I can stay away from regexes, the better. I'm not saying rexeges should be avoided at all cost but it's just that they get thrown around a lot and often they are not the right tool for the job.

If there's one thing browsers are good at, it's handling HTML.

```javascript
const encodeHtml = (() => {
  const textarea = document.createElement("textarea");

  return (str) => {
    textarea.innerHTML = "";
    textarea.appendChild(new Text(str));

    return textarea.innerHTML;
  };
})();

const htmlEncodedString = encodeHtml(
  `Hello world <img src="" onerror="alert('xss')" />`
);

console.log(htmlEncodedString);
```

### Extract text from HTML string

```javascript
const stripHtml = (html) => {
  const { documentElement } = new DOMParser().parseFromString(
    html,
    "text/html"
  );

  return documentElement.textContent;
};

const text = stripHtml(`Hello world <img src="" onerror="alert('xss')" />`);

console.log(text);
```

### Removing Accents in a String

Gone are the days where we had to use lodash's [`deburr`](https://lodash.com/docs/4.17.15#deburr) function to remove accents from a string.

```javascript
const removeAccents = (str) => {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
};

const output = removeAccents("Hétérogénéité");

console.log(output);
```

## Email Address Validation

This technique leverages the build-in browser validation.

Constraint Validation API: https://developer.mozilla.org/en-US/docs/Web/API/Constraint_validation

```javascript
const validateEmail = (() => {
  const input = document.createElement("input");

  input.type = "email";
  input.required = true;

  return (email) => {
    input.value = email;

    return input.checkValidity();
  };
})();

console.log(validateEmail(`test@example.com`));
console.log(validateEmail(`test@localhost`));
console.log(validateEmail(`not-an-email`));
```

This technique won't work server-side as it relies on the DOM API but this doesn't mean that you shouldn't validate email addresses on the backend too.

## Dates

If there's one thing a developer shouldn't have to deal with, it's dates, more specifically: timezones.

## Lazy Loading Images

This one's pretty new so it's not fully supported by every browser yet. As of this writing, Safari is still lagging behind. Even though not every browser supports it, it can still be a good progressive enhancement.
data-src, the disadvantage of such approach is that…

```html
<img src="..." width="100" height="100" alt="..." loading="lazy" />
```

## Other techniques

This is a **non-exhaustive** list.

- scroll snapping
- encryption
- smooth scrolling
