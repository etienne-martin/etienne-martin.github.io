export const metadata = {
  date: "2022-02-18T19:26:54.937Z",
  title: "Let the Browser Do It for You",
  description: "A dummy description",
  image: require("./browser.png"),
  imageAlt: "A little browser lifting weights",
};

Browsers are an incredible feat of engineering. According to wikipedia, the Chromium codebase contains about [35 million lines of source code](<https://en.wikipedia.org/wiki/Chromium_(web_browser)#:~:text=35%20million%20source%20lines%20of%20code.>). It's honestly so mind boggling to me that they work at all.

While browsers can do a ton of stuff, there are features we developers have to implement ourselves because they are not supported natively.

In those cases we either:

- handcraft the missing functionality ourselves
- install yet another package while wishing we didn't have to add another 50kb to our JavaScript bundle

Using built-in browser features is not a novel idea. Choosing `border-radius` over background sprites may sound obvious nowadays but we have to keep in mind that things move quickly. There are a lot of things we take for granted that were just hopes and dreams not long ago. Something that can't be done today might be possible next year so it's important to keep up with what's getting shipped.

I've realised that once I have found a way of doing something, I tend to stick with it and accept it as the status quo. I'll be out there reusing techniques from my old bag of tricks without revisiting them to see if anything changed in the browser landscape.

This post is mostly a reminder to myself that I don't always need to re-invent the wheel and that I can, in most cases, rely on the browser to do the heavy lifting for me.

You have a choice as a developer, you can choose to go the hard way, or you can **let the browser do it for you**.

## Before we start

I need to mention that it's not always possible to rely on some of the techniques below if you are building an isomorphic application since some of them rely on browser APIs that aren't available in the Node.js runtime. But hey, things move fast, I'm looking at you [#41749](https://github.com/nodejs/node/pull/41749).

### But why would you want to do that?

The most obvious reasons for me is. Not only we don't have to spend time re-writing code that smarter people already wrote before us, we can also enjoy these benefits:

- **It's fast** - Browser API are almost always going to be faster than their JavaScript counterpart.
- **Size** - By relying on code that's shipped with the browser, we don't need to add yet another library which would increase the size of your JavaScript bundle.
- **Robustness** - The code has been battle-tested.
- **Maintainability** - The most maintainable code is no code at all.

## URLs

Let's start with the basics. Dealing with URLs is super common when developing websites. It's also super hard to get right if trying to do it by hand. There are so many edge cases, better let the browser handle them.

### Query String Parsing

There is this thing called [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and it's super handy when you need to extract values from a query string.

```javascript
const queryParams = new URLSearchParams("?query=1&test=Hello%20World");

console.log(queryParams.get("query"));
console.log(queryParams.get("test"));
```

A little bonus function for parsing a query string into a plain object:

```javascript
const parseQueryString = (queryString) => {
  return Object.fromEntries(new URLSearchParams(queryString));
};

const queryParams = parseQueryString(`?query=1&test=Hello%20World`);

console.log(queryParams);
```

### Manipulating query strings

I've lost count of the number of times I've seen API calls like this:

```javascript
const someString = "someString";
const someBoolean = true;
const someNumber = 42;

await fetch(
  `https://example.com?a=${encodeURIComponent(
    someString
  )}&b=${someBoolean}&c=${someNumber}`
);
```

While this works, there are many things wrong with this approach:

- It is hard to read, even more so with prettier doing its best to keep the line length under control.
- It's fragile, we're one bad keystroke away from messing up our URL.
- We have to remember to call `encodeURIComponent` to properly encode string parameters

In the past I've used the [qs](https://www.npmjs.com/package/qs) package to address all the above but there is better alternative.

There is this thing called [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and it happens to be really well supported.

```javascript
const someString = "someString";
const someBoolean = true;
const someNumber = 42;

const queryString = new URLSearchParams({
  a: someString,
  b: someBoolean,
  c: someNumber,
});

await fetch(`https://example.com?${queryString}`);
```

Compared to the first example above, I think this looks much cleaner.

This is even fully supported by Node.js since version 10 âœ¨

### Manipulating URLs

I think we've all been there before, we're in a rush, and we need to extract some data from a URL.
So we whip out the `slice` method, start slicing pieces off and we eventually end up giving birth to a monstrosity that barely works.

```javascript
// ðŸš« Don't do this
const extractQueryStringFromUrl = (url) => {
  return url.slice(url.indexOf("?") + 1);
};

// Works
console.log(extractQueryStringFromUrl("http://localhost?test=1"));

// Fails
console.log(extractQueryStringFromUrl("http://localhost?test=1#hash"));
console.log(extractQueryStringFromUrl("http://localhost"));
```

**Parsing URLs is hard**, and doing it by hand is rarely a good idea.

Luckily, browsers can parse URLs with a single line of code:

```javascript
const url = new URL("https://example.com:3000/path?test=1#hash");

console.log(url.protocol);
console.log(url.hostname);
console.log(url.pathname);
console.log(url.search);
console.log(url.hash);
// And many others...
```

Here's a little bonus code snippet if you ever need to convert a URL into a plain object:

```javascript
const parseUrl = (url) => {
  const {
    origin,
    protocol,
    username,
    password,
    host,
    hostname,
    port,
    pathname,
    search,
    searchParams,
    hash,
    href,
  } = new URL(url);

  return {
    origin,
    protocol,
    username,
    password,
    host,
    hostname,
    port,
    pathname,
    search,
    searchParams: Object.fromEntries(searchParams),
    hash,
    href,
  };
};

const url = parseUrl(
  "https://username:password@example.com:3000/path?query=1#hash"
);

console.log(url);
```

### Absolute URLs

The `URL` constructor can also be used for converting relative URLs into absolute ones, similar to `url.resolve` in Node.js.

```javascript
const convertToAbsoluteUrl = (base, relativeUrl) => {
  return new URL(relativeUrl, base).toString();
};

const BASE_URL = "https://base-url/path/";

console.log(convertToAbsoluteUrl(BASE_URL, "/relative-path"));
console.log(convertToAbsoluteUrl(BASE_URL, "relative-path"));
console.log(convertToAbsoluteUrl(BASE_URL, "../relative-path"));
```

## Strings

### HTML String Encoding

- using a [textNode](http://developer.mozilla.org/en-US/docs/Web/API/Document/createTextNode)
- using a [link to another page](/) with a piece of `inline code`
- using a [link to an external webite](https://example.com)

We sometimes need to sanitize untrusted strings, these are usually strings of text that are provided by users. This technique helps prevent XSS attacks by encoding strings before rendering them into our document.

If you look on the internet for how to html-encode a piece of text, you will mostly find answers that involves regexes:

- [How to encode a string in JavaScript for displaying in HTML?](https://stackoverflow.com/questions/14129953/how-to-encode-a-string-in-javascript-for-displaying-in-html)
- [How to escape HTML](https://stackoverflow.com/questions/3043775/how-to-escape-html)

Personally, the more I can stay away from regexes, the better. I'm not saying rexeges should be avoided at all cost but it's just that they get thrown around a lot and often they are not the right tool for the job.

If there's one thing browsers are good at, it's handling HTML.

```javascript
const encodeHtml = (() => {
  const textarea = document.createElement("textarea");

  return (str) => {
    textarea.innerHTML = "";
    textarea.appendChild(new Text(str));

    return textarea.innerHTML;
  };
})();

const htmlEncodedString = encodeHtml(
  `Hello world <img src="" onerror="alert('xss')" />`
);

console.log(htmlEncodedString);
```

### Extract text from HTML string

```javascript
const stripHtml = (html) => {
  const { documentElement } = new DOMParser().parseFromString(
    html,
    "text/html"
  );

  return documentElement.textContent;
};

const text = stripHtml(`Hello world <img src="" onerror="alert('xss')" />`);

console.log(text);
```

### Removing Accents in a String

Gone are the days where we had to use lodash's [`deburr`](https://lodash.com/docs/4.17.15#deburr) function to remove accents from a string.

```javascript
const removeAccents = (str) => {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
};

const output = removeAccents("HÃ©tÃ©rogÃ©nÃ©itÃ©");

console.log(output);
```

## Email Address Validation

This technique leverages the build-in browser validation.

Constraint Validation API: https://developer.mozilla.org/en-US/docs/Web/API/Constraint_validation

```javascript
const validateEmail = (() => {
  const input = document.createElement("input");

  input.type = "email";
  input.required = true;

  return (email) => {
    input.value = email;

    return input.checkValidity();
  };
})();

console.log(validateEmail(`test@example.com`));
console.log(validateEmail(`test@localhost`));
console.log(validateEmail(`not-an-email`));
```

This technique won't work server-side as it relies on the DOM API but this doesn't mean that you shouldn't validate email addresses on the backend too.

## Dates

If there's one thing a developer shouldn't have to deal with, it's dates, more specifically: timezones.

## Lazy Loading Images

This one's pretty new so it's not fully supported by every browser yet. As of this writing, Safari is still lagging behind. Even though not every browser supports it, it can still be a good progressive enhancement.
data-src, the disadvantage of such approach is thatâ€¦

```html
<img src="..." width="100" height="100" alt="..." loading="lazy" />
```

## Other techniques

This is a **non-exhaustive** list.

- scroll snapping
- encryption
- smooth scrolling
